<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timpani Membrane Visualization Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 10px;
            font-weight: 600;
        }

        .status-indicator.success {
            background: rgba(39, 174, 96, 0.1);
            border: 2px solid #27ae60;
            color: #27ae60;
        }

        .status-indicator.error {
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid #e74c3c;
            color: #e74c3c;
        }

        .status-indicator.loading {
            background: rgba(243, 156, 18, 0.1);
            border: 2px solid #f39c12;
            color: #f39c12;
        }

        .controls-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #3498db;
        }

        .control-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-align: center;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        .slider-value {
            font-family: 'Courier New', monospace;
            background: #e9ecef;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #495057;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
        }

        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-weight: 500;
            color: #2c3e50;
            cursor: pointer;
        }

        .visualization-panel {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .membrane-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .membrane-container h3 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
        }

        .membrane-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .info-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .info-panel h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
            text-align: center;
        }

        .mode-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #3498db;
        }

        .mode-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .mode-details {
            font-size: 0.9em;
            color: #666;
            line-height: 1.4;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .control-button {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }

        .control-button.stop {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .control-button.stop:hover {
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .control-button.reset {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }

        .control-button.reset:hover {
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .control-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .parameters-display {
            background: #e8f5e8;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }

        .parameters-display h4 {
            color: #27ae60;
            margin-bottom: 10px;
        }

        .param-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .time-display {
            background: #e3f2fd;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
            text-align: center;
        }

        .time-display h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .time-value {
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            font-weight: bold;
            color: #1976d2;
        }

        .speed-info {
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }

        .debug-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            color: #856404;
            font-size: 0.9em;
        }

        .debug-info h4 {
            margin-bottom: 10px;
            color: #856404;
        }

        @media (max-width: 1200px) {
            .controls-panel {
                grid-template-columns: 1fr;
            }
            
            .visualization-panel {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .button-group {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü•Å Timpani Membrane Cross-Section Visualization</h1>
<div class="visualization-panel">
        <div class="membrane-container">
                <h3>Membrane Cross-Section (Radial Profile)</h3>
                <div class="canvas-container">
                    <canvas class="membrane-canvas" id="membraneCanvas"></canvas>
                </div>
            </div>
		<div class="control-group">
                <h3>Animation Control</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Damping (Œ±)</span>
                        <span class="slider-value" id="dampingValue">0.500</span>
                    </div>
                    <input type="range" class="slider" id="dampingSlider" 
                           min="0" max="1" step="0.01" value="0.5" 
                           oninput="updateDamping()">
                </div>
                
                <div class="button-group">
                    <button class="control-button" onclick="startAnimation()" id="startBtn">‚ñ∂ Start</button>
                    <button class="control-button stop" onclick="stopAnimation()" id="stopBtn">‚èπ Stop</button>
                    <button class="control-button reset" onclick="resetAnimation()" id="resetBtn">‚Ü∫ Reset t=0</button>
                </div>
                
                <div class="button-group">
                    <button class="control-button" onclick="testDataLoad()" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">üîß Test Data Load</button>
                    <button class="control-button" onclick="generateAudio()" style="background: linear-gradient(45deg, #e67e22, #d35400);" id="audioBtn">üîä Generate Audio</button>
                </div>
</div>
            </div>
        
        <div class="controls-panel">
            <div class="control-group">
                <h3>Tension Parameters</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Tension (Pa¬∑m)</span>
                        <span class="slider-value" id="tensionValue">1500</span>
                    </div>
                    <input type="range" class="slider" id="tensionSlider" 
                           min="500" max="8000" step="500" value="1500" 
                           oninput="updateTension()">
                </div>
            </div>
            
            <div class="control-group">
                <h3>Membrane Geometry</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Radius (m)</span>
                        <span class="slider-value" id="radiusValue">0.050</span>
                    </div>
                    <input type="range" class="slider" id="radiusSlider" 
                           min="0" max="3" step="1" value="0" 
                           oninput="updateRadius()">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Depth Ratio</span>
                        <span class="slider-value" id="depthValue">0.4</span>
                    </div>
                    <input type="range" class="slider" id="depthSlider" 
                           min="0" max="3" step="1" value="1" 
                           oninput="updateDepth()">
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="kettleLoaded" onchange="updateKettleMode()">
                    <label for="kettleLoaded">Loaded with Kettle</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="verboseDisplay" onchange="updateVerboseMode()">
                    <label for="verboseDisplay">Verbose Plot Information</label>
                </div>
            </div>
	   <div class="control-group">
  		<h3>Frequency Spectrum (Normalized)</h3>
  		<canvas id="spectrumCanvas" width="400" height="250" style="width: 100%; max-height: 250px;"></canvas>
	   </div>
            
            
        </div>
        
                
            
            <div class="info-panel">
                <h3>Modal Information</h3>
                
                <div class="time-display">
                    <h4>Animation Time</h4>
                    <div class="time-value" id="timeDisplay">0.000 s</div>
                    <div class="speed-info">Animation: 250√ó slower than real-time</div>
                </div>
                
                <div class="parameters-display">
                    <h4>Current Parameters</h4>
                    <div class="param-item">
                        <span>Tension:</span>
                        <span id="currentTension">4500 Pa¬∑m</span>
                    </div>
                    <div class="param-item">
                        <span>Radius:</span>
                        <span id="currentRadius">0.150 m</span>
                    </div>
                    <div class="param-item">
                        <span>Depth Ratio:</span>
                        <span id="currentDepth">0.4</span>
                    </div>
                    <div class="param-item">
                        <span>Surface Density:</span>
                        <span id="currentSurfaceDensity">1.0 kg/m¬≤</span>
                    </div>
                    <div class="param-item">
                        <span>Configuration:</span>
                        <span id="currentConfig">Unloaded</span>
                    </div>
                    <div class="param-item">
                        <span>Modes Found:</span>
                        <span id="modesCount">0/10</span>
                    </div>
                </div>
                
                <div id="modesContainer">
                    <div class="loading">Waiting for data...</div>
                </div>
        </div>
    </div>

    <script>
        // Global variables
        let timpaniData = {loaded: null, unloaded: null};
        let besselJ0Data = null;
        let currentModes = [];
        let animationId = null;
        let startTime = 0;
        let currentTime = 0;
        let isAnimating = false;
        let dataLoaded = false;
        let besselDataLoaded = false;
        
        // Parameters - updated to match your example
        let tension = 1500;       // Pa¬∑m - match your example: 500 Pa¬∑m  
        let radius = 0.05;        // m - match your example: 0.2 m
        let depthRatio = 0.4;    // dimensionless - match your example: 0.4
        let isLoaded = false;    // kettle loaded
        let dampingDisplay = 0.5;
        let dampingReal = 0.001;
        let surfaceDensity = 1.0; // kg/m^2 (updated from 0.1, matches MATLAB)
        let showVerboseInfo = false;
        
        // Animation parameters
        const SLOW_MOTION_FACTOR = 250;
        const DAMPING_EXAGGERATION = 10;
        
        // Mode amplitude ratios in dB (updated values)
        const modeAmplitudesDB = [0, -3, -11, -19, -23, -17, -15, -21, -30, -40];
        
        // Canvas setup
        let canvas, ctx;
        
        // Bessel J0 function
        function besselJ0(x) {
            if (besselDataLoaded && besselJ0Data && besselJ0Data.length > 0) {
                if (x <= besselJ0Data[0].x) {
                    return besselJ0Data[0].j0;
                }
                if (x >= besselJ0Data[besselJ0Data.length - 1].x) {
                    return besselJ0Data[besselJ0Data.length - 1].j0;
                }
                
                for (let i = 0; i < besselJ0Data.length - 1; i++) {
                    if (x >= besselJ0Data[i].x && x <= besselJ0Data[i + 1].x) {
                        const x0 = besselJ0Data[i].x;
                        const x1 = besselJ0Data[i + 1].x;
                        const y0 = besselJ0Data[i].j0;
                        const y1 = besselJ0Data[i + 1].j0;
                        
                        const t = (x - x0) / (x1 - x0);
                        return y0 + t * (y1 - y0);
                    }
                }
            }
            
            // Fallback approximation
            if (Math.abs(x) < 0.001) {
                return 1.0;
            }
            
            if (Math.abs(x) < 8.0) {
                const x2 = x * x;
                const x4 = x2 * x2;
                const x6 = x4 * x2;
                const x8 = x4 * x4;
                
                return 1.0 - x2/4.0 + x4/64.0 - x6/2304.0 + x8/147456.0;
            } else {
                const z = 8.0 / x;
                const z2 = z * z;
                const z4 = z2 * z2;
                
                const P0 = 1.0;
                const P1 = -0.1098628627e-2;
                const P2 = 0.2734510407e-4;
                const P3 = -0.2073370639e-5;
                const P4 = 0.2093887211e-6;
                
                const Q0 = -0.1562499995e-1;
                const Q1 = 0.1430488765e-3;
                const Q2 = -0.6911147651e-5;
                const Q3 = 0.7621095161e-6;
                const Q4 = -0.934945152e-7;
                
                const p = P0 + z2 * (P1 + z2 * (P2 + z2 * (P3 + z2 * P4)));
                const q = z * (Q0 + z2 * (Q1 + z2 * (Q2 + z2 * (Q3 + z2 * Q4))));
                
                return Math.sqrt(2.0 / (Math.PI * x)) * (p * Math.cos(x - Math.PI/4.0) - q * Math.sin(x - Math.PI/4.0));
            }
        }
        
        // Load Bessel J0 data
        async function loadBesselJ0Data() {
            try {
                updateStatus('loading', 'Loading Bessel J0 function data...');
                
                const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                const urls = [
                    './besselJ0_function_points.csv',
                    baseUrl + 'besselJ0_function_points.csv',
                    'besselJ0_function_points.csv'
                ];
                
                let besselDataText = null;
                
                for (const url of urls) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            besselDataText = await response.text();
                            break;
                        }
                    } catch (error) {
                        // Try next URL
                    }
                }
                
                if (!besselDataText) {
                    throw new Error('Could not load besselJ0_function_points.csv. Using approximation instead.');
                }
                
                const lines = besselDataText.trim().split('\n');
                besselJ0Data = [];
                
                const startIndex = lines[0].includes('x') || lines[0].includes('X') ? 1 : 0;
                
                for (let i = startIndex; i < lines.length; i++) {
                    const parts = lines[i].split(',');
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0].trim());
                        const j0 = parseFloat(parts[1].trim());
                        if (!isNaN(x) && !isNaN(j0)) {
                            besselJ0Data.push({ x: x, j0: j0 });
                        }
                    }
                }
                
                if (besselJ0Data.length === 0) {
                    throw new Error('No valid Bessel J0 data found in CSV file.');
                }
                
                besselJ0Data.sort((a, b) => a.x - b.x);
                
                besselDataLoaded = true;
                console.log(`Loaded ${besselJ0Data.length} Bessel J0 data points`);
                console.log(`X range: ${besselJ0Data[0].x} to ${besselJ0Data[besselJ0Data.length-1].x}`);
                
                return true;
                
            } catch (error) {
                console.warn('Failed to load Bessel J0 data:', error.message);
                console.log('Will use built-in approximation instead');
                besselDataLoaded = false;
                return false;
            }
        }
        
        // Update status indicator
        function updateStatus(type, message) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            if (!indicator || !text) {
                console.log(`[Status] ${type.toUpperCase()}: ${message}`);
                return;
            }
            
            indicator.className = `status-indicator ${type}`;
            text.textContent = message;
            
            if (type === 'success') {
                indicator.innerHTML = '<span>‚úÖ</span><span>' + message + '</span>';
            } else if (type === 'error') {
                indicator.innerHTML = '<span>‚ùå</span><span>' + message + '</span>';
            } else if (type === 'loading') {
                indicator.innerHTML = '<span>üìä</span><span>' + message + '</span>';
            }
        }
        
        // Load CSV data
        async function loadTimpaniData() {
            try {
                updateStatus('loading', 'Loading timpani and Bessel data...');
                
                await loadBesselJ0Data();
                
                const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                
                const urls = {
                    loaded: [
                        './timpani_loaded.csv',
                        baseUrl + 'timpani_loaded.csv',
                        'timpani_loaded.csv'
                    ],
                    unloaded: [
                        './timpani_unloaded.csv', 
                        baseUrl + 'timpani_unloaded.csv',
                        'timpani_unloaded.csv'
                    ]
                };
                
                let loadedData = null;
                let unloadedData = null;
                
                for (const url of urls.loaded) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            loadedData = await response.text();
                            break;
                        }
                    } catch (error) {
                        // Try next URL
                    }
                }
                
                for (const url of urls.unloaded) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            unloadedData = await response.text();
                            break;
                        }
                    } catch (error) {
                        // Try next URL
                    }
                }
                
                if (!loadedData || !unloadedData) {
                    throw new Error('Could not load one or both timpani CSV files. Check that timpani_loaded.csv and timpani_unloaded.csv are in the same directory as this HTML file.');
                }
                
                timpaniData.loaded = parseCSV(loadedData);
                timpaniData.unloaded = parseCSV(unloadedData);
                
                dataLoaded = true;
                
                const statusMsg = besselDataLoaded ? 
                    `Data loaded! Timpani: ${timpaniData.loaded.length}+${timpaniData.unloaded.length} rows, Bessel: ${besselJ0Data.length} points` :
                    `Timpani data loaded! ${timpaniData.loaded.length}+${timpaniData.unloaded.length} rows (using Bessel approximation)`;
                
                updateStatus('success', statusMsg);
                
                return true;
                
            } catch (error) {
                console.error('Error loading timpani data:', error);
                updateStatus('error', `Failed to load data files: ${error.message}`);
                
                const modesContainer = document.getElementById('modesContainer');
                if (modesContainer) {
                    modesContainer.innerHTML = `
                        <div class="loading" style="color: #e74c3c;">
                            <p style="font-weight: bold;">‚ùå Error loading data files</p>
                            <p style="margin-top: 10px; font-size: 0.9em;">
                                Make sure the following files are in the same directory:
                            </p>
                            <ul style="text-align: left; margin: 10px 0; font-size: 0.9em;">
                                <li>timpani_visualizer.html</li>
                                <li>timpani_loaded.csv</li>
                                <li>timpani_unloaded.csv</li>
                                <li>besselJ0_function_points.csv (optional)</li>
                            </ul>
                            <p style="margin-top: 10px; font-size: 0.8em;">
                                <strong>Error:</strong> ${error.message}
                            </p>
                        </div>
                    `;
                }
                
                return false;
            }
        }
        
        // Test data loading function with enhanced debugging
        async function testDataLoad() {
            console.log('=== MANUAL DATA LOAD TEST ===');
            const result = await loadTimpaniData();
            
            if (result) {
                console.log('Data load test successful!');
                
                // Debug CSV data structure
                console.log('=== CSV DATA DEBUG ===');
                console.log('Loaded data sample:', timpaniData.loaded.slice(0, 3));
                console.log('Unloaded data sample:', timpaniData.unloaded.slice(0, 3));
                console.log('Total loaded rows:', timpaniData.loaded.length);
                console.log('Total unloaded rows:', timpaniData.unloaded.length);
                
                // Check available parameter combinations
                const loadedTensions = [...new Set(timpaniData.loaded.map(row => row.Tension_Pa_m))].sort((a,b) => a-b);
                const loadedRadii = [...new Set(timpaniData.loaded.map(row => row.Radius_m))].sort((a,b) => a-b);
                const loadedDepths = [...new Set(timpaniData.loaded.map(row => row.Depth_Ratio))].sort((a,b) => a-b);
                
                console.log('Available Tensions:', loadedTensions);
                console.log('Available Radii:', loadedRadii);
                console.log('Available Depth Ratios:', loadedDepths);
                
                // Check current parameter matching
                console.log('=== PARAMETER MATCHING DEBUG ===');
                console.log('Current parameters:', {tension, radius, depthRatio, isLoaded});
                
                const data = isLoaded ? timpaniData.loaded : timpaniData.unloaded;
                console.log(`Using ${isLoaded ? 'loaded' : 'unloaded'} dataset`);
                
                // Find exact matches for current parameters
                const exactMatches = data.filter(row => 
                    row.Tension_Pa_m === tension &&
                    row.Radius_m === radius &&
                    row.Depth_Ratio === depthRatio
                );
                console.log('Exact parameter matches:', exactMatches.length);
                if (exactMatches.length > 0) {
                    console.log('First few exact matches:', exactMatches.slice(0, 5));
                }
                
                // Find close matches (with tolerance)
                const closeMatches = data.filter(row => 
                    Math.abs(row.Tension_Pa_m - tension) < 1 &&
                    Math.abs(row.Radius_m - radius) < 0.001 &&
                    Math.abs(row.Depth_Ratio - depthRatio) < 0.01 &&
                    row.Mode_Number <= 10
                );
                console.log('Close parameter matches (with tolerance):', closeMatches.length);
                if (closeMatches.length > 0) {
                    console.log('Close matches:', closeMatches);
                }
                
                updateModes();
                setupCanvas();
                drawCrossSection(0);
            } else {
                console.log('Data load test failed!');
                drawCrossSection(0);
            }
        }
        
        // Parse CSV data with enhanced error checking
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV file appears to be empty or invalid');
            }
            
            const headers = lines[0].split(',').map(h => h.trim());
            console.log('CSV Headers found:', headers);
            
            // Check for expected headers
            const expectedHeaders = ['Tension_Pa_m', 'Radius_m', 'Depth_Ratio', 'B_Parameter', 'Eigenvalue_X', 'Frequency_Hz', 'Mode_Number'];
            const missingHeaders = expectedHeaders.filter(h => !headers.includes(h));
            if (missingHeaders.length > 0) {
                console.warn('Missing expected headers:', missingHeaders);
                console.log('Available headers:', headers);
            }
            
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn(`Row ${i} has ${values.length} values but ${headers.length} headers. Skipping.`);
                    continue;
                }
                
                const row = {};
                headers.forEach((header, index) => {
                    const value = values[index];
                    if (!isNaN(value) && value !== '') {
                        row[header] = parseFloat(value);
                    } else {
                        row[header] = value;
                    }
                });
                
                // Validate that we have the critical fields
                if (row.Frequency_Hz && row.Mode_Number && row.Tension_Pa_m && row.Radius_m && row.Depth_Ratio) {
                    data.push(row);
                } else {
                    console.warn(`Row ${i} missing critical data:`, row);
                }
            }
            
            console.log(`Successfully parsed ${data.length} valid rows from ${lines.length - 1} total rows`);
            
            // Show sample of parsed data
            if (data.length > 0) {
                console.log('Sample parsed data (first 3 rows):');
                data.slice(0, 3).forEach((row, idx) => {
                    console.log(`  Row ${idx + 1}:`, {
                        Mode: row.Mode_Number,
                        Freq: row.Frequency_Hz,
                        Tension: row.Tension_Pa_m,
                        Radius: row.Radius_m,
                        Depth: row.Depth_Ratio,
                        Eigenvalue: row.Eigenvalue_X
                    });
                });
            }
            
            return data;
        }
        
        // Setup canvas
        function setupCanvas() {
            canvas = document.getElementById('membraneCanvas');
            ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width - 20;
            canvas.height = rect.height - 20;
            canvas.style.width = (rect.width - 20) + 'px';
            canvas.style.height = (rect.height - 20) + 'px';
        }
        
        // Update parameter functions
        function updateTension() {
            tension = parseInt(document.getElementById('tensionSlider').value);
            document.getElementById('tensionValue').textContent = tension;
            updateParameters();
            updateModes();
        }
        
        function updateRadius() {
            const radiusIndex = parseInt(document.getElementById('radiusSlider').value);
            const radiusValues = [0.05, 0.1, 0.15, 0.2]; // Match MATLAB: 0.05:0.05:0.2
            radius = radiusValues[radiusIndex];
            document.getElementById('radiusValue').textContent = radius.toFixed(3);
            updateParameters();
            updateModes();
        }
        
        function updateDepth() {
            const depthIndex = parseInt(document.getElementById('depthSlider').value);
            const depthValues = [0.1, 0.4, 0.75, 1.0]; // Match MATLAB exactly
            depthRatio = depthValues[depthIndex];
            document.getElementById('depthValue').textContent = depthRatio;
            updateParameters();
            updateModes();
        }
        
        function updateKettleMode() {
            isLoaded = document.getElementById('kettleLoaded').checked;
            updateParameters();
            updateModes();
        }
        
        function updateVerboseMode() {
            showVerboseInfo = document.getElementById('verboseDisplay').checked;
            if (currentModes.length > 0) {
                drawCrossSection(currentTime);
            }
        }
        
        function updateDamping() {
            dampingDisplay = parseFloat(document.getElementById('dampingSlider').value);
            dampingReal = dampingDisplay * 0.005;
            document.getElementById('dampingValue').textContent = dampingDisplay.toFixed(3);
        }
        
        function updateParameters() {
            document.getElementById('currentTension').textContent = tension + ' Pa¬∑m';
            document.getElementById('currentRadius').textContent = radius.toFixed(3) + ' m';
            document.getElementById('currentDepth').textContent = depthRatio;
            document.getElementById('currentSurfaceDensity').textContent = surfaceDensity.toFixed(1) + ' kg/m¬≤';
            document.getElementById('currentConfig').textContent = isLoaded ? 'Loaded' : 'Unloaded';
        }
        
        // Find matching modes in the data with enhanced debugging
        function updateModes() {
            if (!dataLoaded || !timpaniData.loaded || !timpaniData.unloaded) {
                console.log('Data not loaded yet');
                return;
            }
            
            const data = isLoaded ? timpaniData.loaded : timpaniData.unloaded;
            console.log(`=== UPDATE MODES DEBUG ===`);
            console.log(`Using ${isLoaded ? 'loaded' : 'unloaded'} dataset with ${data.length} rows`);
            console.log('Current parameters:', {tension, radius, depthRatio, isLoaded});
            
            // Calculate wave speed
            const waveSpeed = Math.sqrt(tension / surfaceDensity);
            console.log(`Wave speed c = sqrt(${tension}/${surfaceDensity}) = ${waveSpeed.toFixed(2)} m/s`);
            
            // Find modes that match current parameters
            const matchingModes = data.filter(row => {
                const tensionMatch = Math.abs(row.Tension_Pa_m - tension) < 1;
                const radiusMatch = Math.abs(row.Radius_m - radius) < 0.001;
                const depthMatch = Math.abs(row.Depth_Ratio - depthRatio) < 0.01;
                const modeNumberMatch = row.Mode_Number <= 10;
                
                // Only log first few mismatches to avoid spam
                if (!tensionMatch && row.Mode_Number === 1) console.log(`Tension mismatch: CSV=${row.Tension_Pa_m}, Current=${tension}`);
                if (!radiusMatch && row.Mode_Number === 1) console.log(`Radius mismatch: CSV=${row.Radius_m}, Current=${radius}`);
                if (!depthMatch && row.Mode_Number === 1) console.log(`Depth mismatch: CSV=${row.Depth_Ratio}, Current=${depthRatio}`);
                
                return tensionMatch && radiusMatch && depthMatch && modeNumberMatch;
            }).sort((a, b) => a.Mode_Number - b.Mode_Number);
            
            console.log(`Found ${matchingModes.length} matching modes`);
            if (matchingModes.length > 0) {
                console.log('EXACT MATCHES FOUND:');
                matchingModes.forEach(mode => {
                    // Check if frequency field exists and is valid
                    const freqField = mode.Frequency_Hz;
                    const freqStatus = freqField !== undefined ? `${freqField.toFixed(6)} Hz` : 'UNDEFINED/MISSING';
                    
                    console.log(`  Mode ${mode.Mode_Number}: T=${mode.Tension_Pa_m}, R=${mode.Radius_m}, D=${mode.Depth_Ratio}`);
                    console.log(`    Eigenvalue: ${mode.Eigenvalue_X ? mode.Eigenvalue_X.toFixed(6) : 'UNDEFINED'}`);
                    console.log(`    Frequency: ${freqStatus}`);
                    console.log(`    Raw row data:`, mode);
                    
                    // Theoretical frequency check (for verification)
                    if (mode.Eigenvalue_X) {
                        const theoreticalFreq = (mode.Eigenvalue_X * waveSpeed) / (2 * Math.PI * radius);
                        console.log(`    Theoretical f = (Œª*c)/(2œÄr) = (${mode.Eigenvalue_X.toFixed(6)}*${waveSpeed.toFixed(2)})/(2œÄ*${radius}) = ${theoreticalFreq.toFixed(2)} Hz`);
                    }
                });
                
                // Check for data corruption or wrong field names
                console.log('=== FIELD VALIDATION ===');
                const firstMode = matchingModes[0];
                console.log('Available fields in first mode:', Object.keys(firstMode));
                console.log('Field types:', Object.entries(firstMode).map(([key, value]) => `${key}: ${typeof value}`));
                
            } else {
                // If no matches, show what's available for current tension
                console.log('No exact matches found. Checking available combinations for current tension...');
                const currentTensionData = data.filter(row => Math.abs(row.Tension_Pa_m - tension) < 1);
                console.log(`Found ${currentTensionData.length} rows with tension ${tension}`);
                
                if (currentTensionData.length > 0) {
                    const uniqueCombos = {};
                    currentTensionData.forEach(row => {
                        const key = `R:${row.Radius_m}_D:${row.Depth_Ratio}`;
                        if (!uniqueCombos[key]) {
                            uniqueCombos[key] = {
                                radius: row.Radius_m,
                                depth: row.Depth_Ratio,
                                modes: [],
                                freqs: []
                            };
                        }
                        uniqueCombos[key].modes.push(row.Mode_Number);
                        if (row.Frequency_Hz !== undefined) {
                            uniqueCombos[key].freqs.push(row.Frequency_Hz.toFixed(1));
                        } else {
                            uniqueCombos[key].freqs.push('UNDEF');
                        }
                    });
                    
                    console.log(`Available R,D combinations for tension ${tension}:`);
                    Object.values(uniqueCombos).slice(0, 5).forEach(combo => {
                        console.log(`  R=${combo.radius}, D=${combo.depth} -> Modes: ${combo.modes.sort((a,b)=>a-b).join(',')} -> Freqs: ${combo.freqs.slice(0,3).join(',')}...`);
                    });
                }
                
                // Also check if current R,D combination exists with different tension
                const currentRDData = data.filter(row => 
                    Math.abs(row.Radius_m - radius) < 0.001 && 
                    Math.abs(row.Depth_Ratio - depthRatio) < 0.01
                );
                if (currentRDData.length > 0) {
                    const tensions = [...new Set(currentRDData.map(row => row.Tension_Pa_m))].sort((a,b) => a-b);
                    console.log(`Current R=${radius}, D=${depthRatio} combination exists with tensions: ${tensions.join(', ')}`);
                    
                    // Show sample frequencies for the first available tension
                    if (tensions.length > 0) {
                        const sampleData = currentRDData.filter(row => row.Tension_Pa_m === tensions[0] && row.Mode_Number <= 5);
                        console.log(`Sample frequencies for T=${tensions[0]}, R=${radius}, D=${depthRatio}:`);
                        sampleData.forEach(row => {
                            const freq = row.Frequency_Hz !== undefined ? row.Frequency_Hz.toFixed(6) : 'UNDEFINED';
                            console.log(`  Mode ${row.Mode_Number}: ${freq} Hz (Eigen: ${row.Eigenvalue_X ? row.Eigenvalue_X.toFixed(6) : 'UNDEF'})`);
                        });
                    }
                }
            }
            
            currentModes = matchingModes.slice(0, 10); // Get first 10 modes
            
            // Update modes count
            document.getElementById('modesCount').textContent = `${currentModes.length}/10`;
            
            // Display mode information
            displayModeInfo();
	    
	    drawSpectrumCanvas();

            
            // Draw if not animating
            if (!isAnimating) {
                drawCrossSection(currentTime);
            }
        }

	function drawSpectrumCanvas() {
    const canvas = document.getElementById('spectrumCanvas');
    if (!canvas || !currentModes.length) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);

    const margin = 40;
    const barWidth = (width - 2 * margin) / currentModes.length;
    const maxDB = 0;       // 0 dB is the peak
    const minDB = -40;     // Floor
    const rangeDB = maxDB - minDB;

    const baseFreq = currentModes[0].Frequency_Hz;

    currentModes.forEach((mode, i) => {
        const freq = mode.Frequency_Hz;
        const normalizedFreq = freq / baseFreq;

        const dB = modeAmplitudesDB[i] !== undefined ? modeAmplitudesDB[i] : -40;
        const barHeight = ((dB - minDB) / rangeDB) * (height - 2 * margin);

        const x = margin + i * barWidth;
        const y = height - margin - barHeight;

        // Bar
        ctx.fillStyle = '#3498db';
        ctx.fillRect(x + 5, y, barWidth - 10, barHeight);

        // Label: frequency ratio
        ctx.fillStyle = '#444';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(normalizedFreq.toFixed(2), x + barWidth / 2, height - 10);
    });

    // Y-axis label
    ctx.save();
    ctx.translate(10, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.fillText('Amplitude (dB)', 0, 0);
    ctx.restore();

    // Title
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.fillText('f‚Çô / f‚ÇÅ ‚Üí', width / 2, margin - 10);
}

        
        // Display mode information
        function displayModeInfo() {
            const container = document.getElementById('modesContainer');
            
            if (currentModes.length === 0) {
                container.innerHTML = '<div class="loading">No modes found for current parameters</div>';
                return;
            }
            
            let html = '';
            currentModes.forEach((mode, index) => {
                const amplitudeDB = index < modeAmplitudesDB.length ? modeAmplitudesDB[index] : -60;
                html += `
                    <div class="mode-info">
                        <div class="mode-header">Mode ${mode.Mode_Number}</div>
                        <div class="mode-details">
                            Frequency: ${mode.Frequency_Hz.toFixed(1)} Hz<br>
                            Eigenvalue: ${mode.Eigenvalue_X.toFixed(3)}<br>
                            Amplitude: ${amplitudeDB} dB
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Calculate membrane displacement
        function calculateDisplacement(r, t, exaggerateDamping = false) {
            let displacement = 0;
            
            currentModes.forEach((mode, index) => {
                if (index >= modeAmplitudesDB.length) return;
                
                const Xn = mode.Eigenvalue_X;
                const fn = mode.Frequency_Hz;
                const a = radius;
                const amplitudeDB = modeAmplitudesDB[index];
                const An = Math.pow(10, amplitudeDB / 20);
                
                const radialArg = (Xn / a) * Math.abs(r);
                
                let spatialPart;
                if (isLoaded) {
                    spatialPart = besselJ0(radialArg) - besselJ0(Xn);
                } else {
                    spatialPart = besselJ0(radialArg);
                }
                
                const omega = 2 * Math.PI * fn;
                const temporalPart = Math.cos(omega * t);
                
                const effectiveDamping = exaggerateDamping ? (dampingReal * DAMPING_EXAGGERATION) : dampingReal;
                const dampingFactor = Math.exp(-effectiveDamping * omega * t);
                
                displacement += An * spatialPart * temporalPart * dampingFactor;
            });
            
            return displacement;
        }
        
        // Animation functions
        function startAnimation() {
            if (isAnimating || currentModes.length === 0) {
                if (currentModes.length === 0) {
                    alert('Please load CSV data first or check that modes are found for current parameters');
                }
                return;
            }
            
            isAnimating = true;
            startTime = performance.now();
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            animate();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        function resetAnimation() {
            stopAnimation();
            currentTime = 0;
            document.getElementById('timeDisplay').textContent = '0.000 s';
            if (currentModes.length > 0) {
                drawCrossSection(0);
            }
        }
        
        function animate() {
            if (!isAnimating) return;
            
            const elapsedMs = performance.now() - startTime;
            currentTime = elapsedMs / 1000 / SLOW_MOTION_FACTOR;
            
            document.getElementById('timeDisplay').textContent = currentTime.toFixed(3) + ' s';
            
            drawCrossSection(currentTime);
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Draw membrane cross-section
        function drawCrossSection(t) {
            if (!canvas || !ctx) {
                console.error('Canvas not initialized');
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const width = canvas.width;
            const height = canvas.height;
            const margin = 60;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            // Draw background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // Draw plot area
            ctx.fillStyle = 'white';
            ctx.fillRect(margin, margin, plotWidth, plotHeight);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            const rSteps = 10;
            for (let i = 0; i <= rSteps; i++) {
                const x = margin + (i / rSteps) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, margin + plotHeight);
                ctx.stroke();
            }
            
            const ySteps = 8;
            for (let i = 0; i <= ySteps; i++) {
                const y = margin + (i / ySteps) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(margin + plotWidth, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            const centerX = margin + plotWidth / 2;
            ctx.beginPath();
            ctx.moveTo(centerX, margin);
            ctx.lineTo(centerX, margin + plotHeight);
            ctx.stroke();
            
            const zeroY = margin + plotHeight / 2;
            ctx.beginPath();
            ctx.moveTo(margin, zeroY);
            ctx.lineTo(margin + plotWidth, zeroY);
            ctx.stroke();
            
            // Calculate and draw displacement curve
            if (currentModes.length > 0) {
                // Draw static envelope
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                
                const points = 200;
                let maxStaticDisplacement = 0;
                const staticDisplacements = [];
                
                for (let i = 0; i <= points; i++) {
                    const r = -radius + (2 * radius * i) / points;
                    let staticDisplacement = 0;
                    
                    currentModes.forEach((mode, index) => {
                        if (index >= modeAmplitudesDB.length) return;
                        
                        const Xn = mode.Eigenvalue_X;
                        const fn = mode.Frequency_Hz;
                        const a = radius;
                        const amplitudeDB = modeAmplitudesDB[index];
                        const An = Math.pow(10, amplitudeDB / 20);
                        
                        const radialArg = (Xn / a) * Math.abs(r);
                        
                        let spatialPart;
                        if (isLoaded) {
                            spatialPart = besselJ0(radialArg) - besselJ0(Xn);
                        } else {
                            spatialPart = besselJ0(radialArg);
                        }
                        
                        const omega = 2 * Math.PI * fn;
                        const dampingFactor = Math.exp(-dampingReal * DAMPING_EXAGGERATION * omega * t);
                        
                        staticDisplacement += An * spatialPart * dampingFactor;
                    });
                    
                    staticDisplacements.push(staticDisplacement);
                    maxStaticDisplacement = Math.max(maxStaticDisplacement, Math.abs(staticDisplacement));
                }
                
                const staticScale = maxStaticDisplacement > 0 ? (plotHeight * 0.35) / maxStaticDisplacement : 1;
                for (let i = 0; i <= points; i++) {
                    const x = margin + (i / points) * plotWidth;
                    const y = zeroY - staticDisplacements[i] * staticScale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw actual displacement
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                let maxDisplacement = 0;
                const displacements = [];
                
                for (let i = 0; i <= points; i++) {
                    const r = -radius + (2 * radius * i) / points;
                    const displacement = calculateDisplacement(r, t, true);
                    displacements.push(displacement);
                    maxDisplacement = Math.max(maxDisplacement, Math.abs(displacement));
                }
                
                const scale = staticScale;
                
                for (let i = 0; i <= points; i++) {
                    const x = margin + (i / points) * plotWidth;
                    const y = zeroY - displacements[i] * scale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Draw membrane boundaries
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, margin + plotHeight);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(margin + plotWidth, margin);
                ctx.lineTo(margin + plotWidth, margin + plotHeight);
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // Add labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                const radiusSteps = 5;
                for (let i = 0; i <= radiusSteps; i++) {
                    const r = -radius + (2 * radius * i) / radiusSteps;
                    const x = margin + (i / radiusSteps) * plotWidth;
                    
                    if (Math.abs(r) < 0.001) {
                        ctx.fillText('0', x, height - 20);
                    } else {
                        ctx.fillText(r.toFixed(3), x, height - 20);
                    }
                }
                
                ctx.textAlign = 'right';
                if (maxStaticDisplacement > 0) {
                    ctx.fillText(`+${maxStaticDisplacement.toFixed(3)}`, margin - 10, margin + 20);
                    ctx.fillText('0', margin - 10, zeroY + 5);
                    ctx.fillText(`-${maxStaticDisplacement.toFixed(3)}`, margin - 10, height - margin - 20);
                }
                
                ctx.textAlign = 'center';
                ctx.fillText('Radial Position r (m)', width / 2, height - 5);
                
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Displacement', 0, 0);
                ctx.restore();
                
                // Add boundary condition labels
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('-a', margin, margin - 5);
                ctx.fillText('+a', margin + plotWidth, margin - 5);
                ctx.fillText('r = 0', centerX, margin - 5);
                
                // Add mode information and temporal info
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Configuration: ${isLoaded ? 'Loaded' : 'Unloaded'}`, margin + 10, margin + 20);
                ctx.fillText(`Modes: ${currentModes.length}/10`, margin + 10, margin + 35);
                
                if (showVerboseInfo && currentModes.length > 0) {
                    // Show detailed information when verbose mode is on
                    const f1 = currentModes[0].Frequency_Hz;
                    ctx.fillText(`f‚ÇÅ = ${f1.toFixed(1)} Hz`, margin + 10, margin + 50);
                    
                    const omega1 = 2 * Math.PI * f1;
                    const cos1 = Math.cos(omega1 * t);
                    const damp1 = Math.exp(-dampingReal * DAMPING_EXAGGERATION * omega1 * t);
                    ctx.fillText(`cos(2œÄf‚ÇÅt) = ${cos1.toFixed(3)}`, margin + 10, margin + 65);
                    ctx.fillText(`e^(-Œ±¬∑2œÄf‚ÇÅ¬∑t) = ${damp1.toFixed(3)}`, margin + 10, margin + 80);
                    
                    const effective1 = cos1 * damp1;
                    ctx.fillText(`Effective = ${effective1.toFixed(3)}`, margin + 10, margin + 95);
                    
                    // Add surface density and updated amplitude info
                    ctx.fillText(`Surface Density œÅ = ${surfaceDensity.toFixed(1)} kg/m¬≤`, margin + 10, margin + 110);
                    ctx.fillText(`Mode Amplitudes (dB): [${modeAmplitudesDB.slice(0, Math.min(5, currentModes.length)).join(', ')}...]`, margin + 10, margin + 125);
                    
                    // Add legend information
                    ctx.fillStyle = '#666';
                    ctx.font = '10px Arial';
                    const besselStatus = besselDataLoaded ? 'CSV data' : 'approximation';
                    ctx.fillText(`Bessel J0: ${besselStatus}`, margin + 10, margin + 140);
                    ctx.fillText(`Damping Œ± = ${dampingDisplay.toFixed(3)} (display)`, margin + 10, margin + 155);
                    ctx.fillText(`Animation: ${DAMPING_EXAGGERATION}√ó exaggerated`, margin + 10, margin + 170);
                    
                    // Legend for the curves
                    ctx.fillStyle = '#cccccc';
                    ctx.fillText('--- Damped envelope (current max)', width - 250, margin + 20);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('‚Äî Current displacement', width - 250, margin + 35);
                    ctx.fillStyle = '#666';
                    ctx.font = '9px Arial';
                    ctx.fillText('cos(2œÄf‚Çôt)¬∑e^(-Œ±¬∑2œÄf‚Çô¬∑t)', width - 250, margin + 50);
                    
                    // Add formula information in verbose mode
                    ctx.fillStyle = '#444';
                    ctx.font = '9px Arial';
                    ctx.fillText('u(r,t) = Œ£ A‚Çô¬∑J‚Çô(Œª‚Çôr/a)¬∑cos(2œÄf‚Çôt)¬∑e^(-Œ±¬∑œâ‚Çô¬∑t)', margin + 10, margin + 185);
                    ctx.fillText(`where Œª‚Çô from eigenvalue equation, f‚Çô from CSV data`, margin + 10, margin + 200);
                } else if (currentModes.length > 0) {
                    // Show minimal information when verbose mode is off
                    const f1 = currentModes[0].Frequency_Hz;
                    ctx.fillText(`f‚ÇÅ = ${f1.toFixed(1)} Hz`, margin + 10, margin + 50);
                    
                    if (showVerboseInfo === false) {
                        ctx.fillStyle = '#888';
                        ctx.font = '10px Arial';
                        ctx.fillText('Enable "Verbose Plot Information" for detailed display', margin + 10, margin + 70);
                    }
                }
                
            } else {
                // No modes available
                ctx.fillStyle = '#999';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No modes available', width / 2, height / 2);
                ctx.fillText('Load CSV data or adjust parameters', width / 2, height / 2 + 25);
                
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Radial Position r (m)', width / 2, height - 5);
                
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Displacement', 0, 0);
                ctx.restore();
                
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('-a', margin, margin - 5);
                ctx.fillText('+a', margin + plotWidth, margin - 5);
                ctx.fillText('r = 0', centerX, margin - 5);
            }
        }
        
        // Generate and play audio
        async function generateAudio() {
            if (currentModes.length === 0) {
                alert('No modes available. Please load data and set parameters first.');
                return;
            }
            
            const audioBtn = document.getElementById('audioBtn');
            audioBtn.disabled = true;
            audioBtn.textContent = '‚è≥ Generating...';
            
            try {
                const sampleRate = 44100;
                const duration = 1.0;
                const numSamples = Math.floor(sampleRate * duration);
                
                if (!window.audioContext) {
                    window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const audioBuffer = window.audioContext.createBuffer(1, numSamples, sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                let maxAmplitude = 0;
                for (let i = 0; i < numSamples; i++) {
                    const t = i / sampleRate;
                    const displacement = calculateDisplacement(0, t, false);
                    channelData[i] = displacement;
                    maxAmplitude = Math.max(maxAmplitude, Math.abs(displacement));
                }
                
                if (maxAmplitude > 0) {
                    const scale = 0.8 / maxAmplitude;
                    for (let i = 0; i < numSamples; i++) {
                        channelData[i] *= scale;
                    }
                }
                
                const source = window.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(window.audioContext.destination);
                source.start();
                
                audioBtn.textContent = 'üîä Audio Playing...';
                
                source.onended = () => {
                    audioBtn.disabled = false;
                    audioBtn.textContent = 'üîä Generate Audio';
                };
                
                setTimeout(() => {
                    audioBtn.disabled = false;
                    audioBtn.textContent = 'üîä Generate Audio';
                }, duration * 1000 + 500);
                
                console.log(`Generated ${duration}s audio at ${sampleRate} Hz`);
                console.log(`Max amplitude: ${maxAmplitude.toFixed(6)}`);
                console.log(`Using ${currentModes.length} modes with real damping Œ±=${dampingReal.toFixed(5)}`);
                
            } catch (error) {
                console.error('Audio generation failed:', error);
                audioBtn.disabled = false;
                audioBtn.textContent = 'üîä Generate Audio';
                alert('Audio generation failed: ' + error.message);
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', async function() {
            console.log('Page loaded, initializing...');
            
            setupCanvas();
            updateParameters();
            drawCrossSection(0);
            
            updateStatus('loading', 'Loading timpani data...');
            const loadResult = await loadTimpaniData();
            
            if (loadResult) {
                console.log('Data loaded successfully, updating modes...');
                updateModes();
                console.log('Drawing cross section...');
                drawCrossSection(0);
            } else {
                console.log('Data loading failed');
                updateStatus('error', 'Failed to load data. Click "Test Data Load" to try again.');
                drawCrossSection(0);
            }
            
            console.log('Initialization complete');
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(() => {
                if (canvas) {
                    setupCanvas();
                    drawCrossSection(currentTime);
                }
            }, 100);
        });
        
        // Debug tools
        window.timpaniDebug = {
            loadTimpaniData,
            loadBesselJ0Data,
            testDataLoad,
            updateModes,
            besselJ0,
            generateAudio,
            getCurrentState: () => ({
                dataLoaded,
                besselDataLoaded,
                timpaniData,
                besselJ0Data: besselJ0Data ? besselJ0Data.length : 0,
                currentModes: currentModes.length,
                tension,
                radius,
                depthRatio,
                isLoaded,
                dampingDisplay,
                dampingReal,
                surfaceDensity,
                showVerboseInfo,
                modeAmplitudesDB,
                dampingExaggeration: DAMPING_EXAGGERATION
            })
        };
    </script>
</body>
</html>