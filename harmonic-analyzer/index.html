<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discrete Sequence Analyzer - MATLAB Stem Style</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            color: #212529;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            min-height: calc(100vh - 40px);
        }
        
        .main-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 25px;
            display: flex;
            flex-direction: column;
        }
        
        .side-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }
        
        .header h1 {
            color: #0f4c75;
            font-size: 1.5em;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .header p {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .plot-container {
            flex: 1;
            background: #fefefe;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            position: relative;
            min-height: 350px;
            max-height: 400px;
            overflow: hidden;
        }
        
        .plot-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .plot-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .plot-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .plot-info {
            font-size: 0.8em;
            color: #6c757d;
        }
        
        .value-editor {
            background: #f0f7ff;
            border: 2px solid #0d6efd;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }
        
        .value-editor h3 {
            color: #0f4c75;
            margin: 0 0 15px 0;
            font-size: 1.1em;
            font-weight: 600;
            text-align: center;
        }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .slider-label {
            font-weight: 500;
            color: #495057;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .slider-value {
            font-family: 'Courier New', monospace;
            background: #e9ecef;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            color: #495057;
        }
        
        .range-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }
        
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0d6efd;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0d6efd;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .current-value-display {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            margin: 10px 0;
        }
        
        .current-value-display .label {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 4px;
        }
        
        .current-value-display .value {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            color: #0f4c75;
        }
        
        .asymmetric-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #ffc107;
            border-radius: 6px;
        }
        
        .asymmetric-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .asymmetric-checkbox label {
            font-size: 0.85em;
            font-weight: 500;
            color: #664d03;
            cursor: pointer;
            flex: 1;
        }
        
        .asymmetric-info {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 8px;
            font-size: 0.8em;
            color: #664d03;
            margin-top: 5px;
            display: none;
        }
        
        .asymmetric-info.active {
            display: block;
        }
        
        .set-value-btn {
            background: linear-gradient(135deg, #0d6efd, #0056b3);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-top: 10px;
            box-shadow: 0 2px 8px rgba(13, 110, 253, 0.3);
        }
        
        .set-value-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(13, 110, 253, 0.4);
        }
        
        .set-value-btn:active {
            transform: translateY(0);
        }
        
        .set-value-btn.asymmetric {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
        }
        
        .set-value-btn.asymmetric:hover {
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }
        
        .control-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }
        
        .control-section h3 {
            color: #0f4c75;
            margin-bottom: 12px;
            font-size: 1.1em;
            font-weight: 600;
        }
        
        .sequence-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .input-group label {
            font-weight: 500;
            color: #495057;
            font-size: 0.9em;
        }
        
        .input-field {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.9em;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #0d6efd;
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.1);
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            min-height: 40px;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary { background: #0d6efd; color: white; }
        .btn-success { background: #198754; color: white; }
        .btn-warning { background: #fd7e14; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-outline { background: white; color: #0d6efd; border: 1px solid #0d6efd; }
        
        .harmonics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }
        
        .harmonic-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }
        
        .harmonic-label {
            font-weight: 600;
            color: #0f4c75;
            font-size: 0.85em;
            margin-bottom: 4px;
        }
        
        .harmonic-freq {
            font-size: 0.75em;
            color: #6c757d;
            margin-bottom: 6px;
        }
        
        .harmonic-value {
            font-size: 0.8em;
            color: #495057;
        }
        
        .harmonic-phase {
            font-size: 0.75em;
            color: #6f42c1;
            margin-top: 2px;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .status-bar {
            background: #e9ecef;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            color: #495057;
            margin-top: 10px;
        }
        
        .sample-display {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            max-height: 150px;
            overflow-y: auto;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .side-panel {
                order: -1;
            }
            
            .harmonics-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .main-panel, .side-panel {
                padding: 15px;
            }
            
            .plot-container {
                min-height: 400px;
            }
            
            .harmonics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .button-group {
                justify-content: center;
            }
        }
        
        /* Stem plot specific styles */
        .stem-marker {
            fill: #0d6efd;
            stroke: #0d6efd;
            stroke-width: 2;
        }
        
        .stem-marker.asymmetric {
            fill: #ffc107;
            stroke: #ffc107;
        }
        
        .stem-line {
            stroke: #0d6efd;
            stroke-width: 2;
        }
        
        .stem-line.asymmetric {
            stroke: #ffc107;
        }
        
        .interpolated-curve {
            stroke: #dc3545;
            stroke-width: 2;
            fill: none;
            opacity: 0.8;
        }
        
        .grid-lines {
            stroke: #e9ecef;
            stroke-width: 1;
        }
        
        .axis-line {
            stroke: #495057;
            stroke-width: 2;
        }
        
        .axis-text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 11px;
            fill: #495057;
        }
        
        .axis-label {
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
            font-weight: 500;
            fill: #212529;
        }
        
        .legend {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-panel">
            <div class="header">
                <h1>Discrete Sequence Analyzer</h1>
                <p>MATLAB-style stem plot for waveform decomposition and harmonic analysis</p>
            </div>
            
            <div class="plot-toolbar">
                <div class="plot-controls">
                    <button class="btn btn-outline" onclick="zoomIn()">üîç+</button>
                    <button class="btn btn-outline" onclick="zoomOut()">üîç-</button>
                    <button class="btn btn-outline" onclick="resetZoom()">‚Ü∫ Reset</button>
                    <button class="btn btn-outline" onclick="toggleGrid()">‚äû Grid</button>
                </div>
                <div class="plot-info">
                    <span id="plotInfo">Red curve: Harmonic synthesis</span>
                </div>
            </div>
            
            <div class="plot-container">
                <svg class="plot-canvas" id="stemPlot">
                    <!-- Plot will be drawn here -->
                </svg>
            </div>
            
            <div class="status-bar" id="statusBar">
                Ready ‚Ä¢ Fundamental: 440 Hz ‚Ä¢ Period: 2.27 ms ‚Ä¢ Samples: 21
            </div>
        </div>
        
        <div class="side-panel">
            <!-- Value Editor -->
            <div class="value-editor">
                <h3>üìä Sample Value Editor</h3>
                <div class="slider-group">
                    <div class="slider-container">
                        <div class="slider-label">
                            Sample Index (n)
                            <span class="slider-value" id="indexValue">0</span>
                        </div>
                        <input type="range" class="range-slider" id="sampleIndexSlider" 
                               min="0" max="20" value="0" step="1" 
                               oninput="updateIndexDisplay()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            Amplitude
                            <span class="slider-value" id="amplitudeValue">0.000</span>
                        </div>
                        <input type="range" class="range-slider" id="amplitudeSlider" 
                               min="-1" max="1" value="0" step="0.001" 
                               oninput="updateAmplitudeDisplay()">
                    </div>
                </div>
                
                <div class="asymmetric-checkbox">
                    <input type="checkbox" id="asymmetricMode" onchange="toggleAsymmetricMode()">
                    <label for="asymmetricMode">Asymmetric Setting (Mirror Mode)</label>
                </div>
                
                <div class="asymmetric-info" id="asymmetricInfo">
                    Setting x[<span id="primaryIndex">0</span>] = A and x[<span id="mirrorIndex">20</span>] = -A
                </div>
                
                <div class="current-value-display">
                    <div class="label">Current Value at Selected Index</div>
                    <div class="value" id="currentSampleValue">x[0] = 0.000</div>
                </div>
                
                <button class="set-value-btn" id="setValueBtn" onclick="setSampleValue()">
                    üîß Set Value
                </button>
            </div>
            
            <!-- Sequence Parameters -->
            <div class="control-section">
                <h3>Sequence Parameters</h3>
                <div class="sequence-controls">
                    <div class="input-group">
                        <label for="sampleCount">Number of Samples (N)</label>
                        <input type="number" id="sampleCount" class="input-field" value="21" min="8" max="128" onchange="updateSampleCount()">
                    </div>
                    <div class="input-group">
                        <label for="fundamentalFreq">Fundamental Frequency (Hz)</label>
                        <input type="number" id="fundamentalFreq" class="input-field" value="440" min="100" max="2000" step="10" onchange="updateFundamental()">
                    </div>
                    <div class="input-group">
                        <label for="amplitudeRange">Amplitude Range</label>
                        <select id="amplitudeRange" class="input-field" onchange="updateAmplitudeRange()">
                            <option value="2">¬±1.0</option>
                            <option value="4">¬±2.0</option>
                            <option value="10">¬±5.0</option>
                            <option value="20">¬±10.0</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Preset Waveforms -->
            <div class="control-section">
                <h3>Preset Waveforms</h3>
                <div class="preset-buttons">
                    <button class="btn btn-secondary" onclick="loadSineWave()">Sine</button>
                    <button class="btn btn-secondary" onclick="loadSquareWave()">Square</button>
                    <button class="btn btn-secondary" onclick="loadSawtoothWave()">Sawtooth</button>
                    <button class="btn btn-secondary" onclick="loadTriangleWave()">Triangle</button>
                    <button class="btn btn-secondary" onclick="loadImpulse()">Impulse</button>
                    <button class="btn btn-secondary" onclick="loadNoise()">Noise</button>
                </div>
            </div>
            
            <!-- Analysis Controls -->
            <div class="control-section">
                <h3>Analysis & Playback</h3>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="analyzeSequence()">üî¨ Analyze</button>
                    <button class="btn btn-success" id="playBtn" onclick="playSequence()">‚ñ∂Ô∏è Play</button>
                    <button class="btn btn-warning" onclick="stopPlayback()">‚èπÔ∏è Stop</button>
                </div>
                <div class="button-group" style="margin-top: 8px;">
                    <button class="btn btn-outline" onclick="scramblePhases()">üé≤ Random Phase</button>
                    <button class="btn btn-danger" onclick="clearSequence()">üóëÔ∏è Clear</button>
                </div>
            </div>
            
            <!-- Harmonic Analysis -->
            <div class="control-section">
                <h3>Harmonic Components</h3>
                <div class="harmonics-grid" id="harmonicsDisplay">
                    <!-- Harmonic components will be populated here -->
                </div>
            </div>
            
            <!-- Data Export -->
            <div class="control-section">
                <h3>Export Data</h3>
                <div class="button-group">
                    <button class="btn btn-outline" onclick="exportCSV()">üìä CSV</button>
                    <button class="btn btn-outline" onclick="exportWAV()">üéµ WAV</button>
                    <button class="btn btn-outline" onclick="exportJSON()">üíæ JSON</button>
                </div>
                <input type="file" id="importFile" style="display: none;" accept=".json,.csv" onchange="importData(event)">
                <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()" style="width: 100%; margin-top: 8px;">üìÅ Import</button>
            </div>
            
            <!-- Sample Values Display -->
            <div class="control-section">
                <h3>Sample Values</h3>
                <div class="sample-display" id="sampleValues">
                    Click "Analyze" to see sample values...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let sequenceData = [];
        let harmonicAmps = [];
        let harmonicPhases = [];
        let sampleCount = 21;
        let fundamentalFreq = 440;
        let amplitudeRange = 2; // ¬±1.0
        let audioContext = null;
        let currentSource = null;
        let showGrid = true;
        let zoomLevel = 1;
        let panOffset = { x: 0, y: 0 };
        let asymmetricMode = false;
        let lastAsymmetricIndices = [];
        
        // Plot dimensions
        const plotMargin = { top: 40, right: 40, bottom: 60, left: 60 };
        let plotWidth = 800;
        let plotHeight = 500;
        
        // Initialize the application
        function init() {
            initAudio();
            initPlot();
            generateDefaultSequence();
            updateHarmonicsDisplay();
            drawPlot();
            updateSampleDisplay();
            initValueEditor();
        }
        
        // Initialize value editor
        function initValueEditor() {
            updateSliderRanges();
            updateIndexDisplay();
            updateAmplitudeDisplay();
            updateCurrentValueDisplay();
        }
        
        // Update slider ranges based on current settings
        function updateSliderRanges() {
            const indexSlider = document.getElementById('sampleIndexSlider');
            const amplitudeSlider = document.getElementById('amplitudeSlider');
            
            indexSlider.max = sampleCount - 1;
            amplitudeSlider.min = -amplitudeRange/2;
            amplitudeSlider.max = amplitudeRange/2;
            
            // Reset to valid values if out of range
            if (parseInt(indexSlider.value) >= sampleCount) {
                indexSlider.value = 0;
            }
            
            const currentAmp = parseFloat(amplitudeSlider.value);
            if (currentAmp < -amplitudeRange/2 || currentAmp > amplitudeRange/2) {
                amplitudeSlider.value = 0;
            }
        }
        
        // Update index display
        function updateIndexDisplay() {
            const slider = document.getElementById('sampleIndexSlider');
            const display = document.getElementById('indexValue');
            display.textContent = slider.value;
            updateCurrentValueDisplay();
            updateAsymmetricInfo();
        }
        
        // Update amplitude display
        function updateAmplitudeDisplay() {
            const slider = document.getElementById('amplitudeSlider');
            const display = document.getElementById('amplitudeValue');
            display.textContent = parseFloat(slider.value).toFixed(3);
        }
        
        // Update current value display
        function updateCurrentValueDisplay() {
            const indexSlider = document.getElementById('sampleIndexSlider');
            const index = parseInt(indexSlider.value);
            const currentValue = sequenceData[index] || 0;
            const display = document.getElementById('currentSampleValue');
            
            if (asymmetricMode) {
                const mirrorIndex = sampleCount - 1 - index;
                const mirrorValue = sequenceData[mirrorIndex] || 0;
                display.textContent = `x[${index}] = ${currentValue.toFixed(3)}, x[${mirrorIndex}] = ${mirrorValue.toFixed(3)}`;
            } else {
                display.textContent = `x[${index}] = ${currentValue.toFixed(3)}`;
            }
            
            // Update amplitude slider to show current value
            const amplitudeSlider = document.getElementById('amplitudeSlider');
            amplitudeSlider.value = currentValue;
            updateAmplitudeDisplay();
        }
        
        // Toggle asymmetric mode
        function toggleAsymmetricMode() {
            const checkbox = document.getElementById('asymmetricMode');
            const info = document.getElementById('asymmetricInfo');
            const btn = document.getElementById('setValueBtn');
            
            asymmetricMode = checkbox.checked;
            
            if (asymmetricMode) {
                info.classList.add('active');
                btn.classList.add('asymmetric');
                btn.innerHTML = 'üîß Set Asymmetric Values';
            } else {
                info.classList.remove('active');
                btn.classList.remove('asymmetric');
                btn.innerHTML = 'üîß Set Value';
                
                // Clear last asymmetric highlighting
                lastAsymmetricIndices = [];
                drawPlot();
            }
            
            updateAsymmetricInfo();
            updateCurrentValueDisplay();
        }
        
        // Update asymmetric info display
        function updateAsymmetricInfo() {
            if (!asymmetricMode) return;
            
            const indexSlider = document.getElementById('sampleIndexSlider');
            const index = parseInt(indexSlider.value);
            const mirrorIndex = sampleCount - 1 - index;
            
            document.getElementById('primaryIndex').textContent = index;
            document.getElementById('mirrorIndex').textContent = mirrorIndex;
        }
        
        // Set sample value (with asymmetric support)
        function setSampleValue() {
            const indexSlider = document.getElementById('sampleIndexSlider');
            const amplitudeSlider = document.getElementById('amplitudeSlider');
            
            const index = parseInt(indexSlider.value);
            const amplitude = parseFloat(amplitudeSlider.value);
            
            // Clear previous asymmetric highlighting
            lastAsymmetricIndices = [];
            
            if (asymmetricMode) {
                const mirrorIndex = sampleCount - 1 - index;
                
                // Update the selected index and its mirror with negative value
                sequenceData[index] = amplitude;
                sequenceData[mirrorIndex] = -amplitude;
                
                // Store indices for highlighting
                lastAsymmetricIndices = [index, mirrorIndex];
                
                updateStatus(`Set x[${index}] = ${amplitude.toFixed(3)}, x[${mirrorIndex}] = ${(-amplitude).toFixed(3)} (Asymmetric)`);
            } else {
                // Update only the selected index
                sequenceData[index] = amplitude;
                updateStatus(`Set x[${index}] = ${amplitude.toFixed(3)}`);
            }
            
            // Update displays and analysis
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            
            // Visual feedback
            const btn = document.querySelector('.set-value-btn');
            const originalText = btn.textContent;
            const originalClass = btn.className;
            
            if (asymmetricMode) {
                btn.textContent = '‚úÖ Asymmetric Values Set!';
                btn.style.background = 'linear-gradient(135deg, #198754, #146c43)';
            } else {
                btn.textContent = '‚úÖ Value Set!';
                btn.style.background = 'linear-gradient(135deg, #198754, #146c43)';
            }
            
            setTimeout(() => {
                btn.textContent = originalText;
                if (asymmetricMode) {
                    btn.style.background = 'linear-gradient(135deg, #ffc107, #e0a800)';
                } else {
                    btn.style.background = 'linear-gradient(135deg, #0d6efd, #0056b3)';
                }
            }, 1000);
        }
        
        // Initialize audio context
        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    // Will be resumed on user interaction
                }
            } catch (error) {
                console.error('Audio initialization failed:', error);
            }
        }
        
        // Initialize plot SVG
        function initPlot() {
            const svg = document.getElementById('stemPlot');
            const container = svg.parentElement;
            
            // Update plot dimensions based on container
            const updateDimensions = () => {
                const rect = container.getBoundingClientRect();
                plotWidth = rect.width - plotMargin.left - plotMargin.right;
                plotHeight = rect.height - plotMargin.top - plotMargin.bottom;
                svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
            };
            
            updateDimensions();
            window.addEventListener('resize', updateDimensions);
        }
        
        // Generate default sine wave sequence
        function generateDefaultSequence() {
            sequenceData = [];
            for (let n = 0; n < sampleCount; n++) {
                const phase = (2 * Math.PI * n) / sampleCount;
                sequenceData.push(Math.sin(phase) * 0.8);
            }
            analyzeSequence();
        }
        
        // Handle plot clicks for editing points
        function handlePlotClick(event) {
            const svg = document.getElementById('stemPlot');
            const rect = svg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Convert screen coordinates to data coordinates
            const dataX = ((x - plotMargin.left) / plotWidth) * sampleCount;
            const dataY = amplitudeRange * (1 - (y - plotMargin.top) / plotHeight) - amplitudeRange/2;
            
            // Find nearest sample index
            const sampleIndex = Math.round(dataX);
            
            if (sampleIndex >= 0 && sampleIndex < sampleCount) {
                // Clamp amplitude to range
                const clampedAmplitude = Math.max(-amplitudeRange/2, Math.min(amplitudeRange/2, dataY));
                
                if (asymmetricMode) {
                    const mirrorIndex = sampleCount - 1 - sampleIndex;
                    sequenceData[sampleIndex] = clampedAmplitude;
                    sequenceData[mirrorIndex] = -clampedAmplitude;
                    lastAsymmetricIndices = [sampleIndex, mirrorIndex];
                    updateStatus(`Sample ${sampleIndex}: ${clampedAmplitude.toFixed(3)}, Sample ${mirrorIndex}: ${(-clampedAmplitude).toFixed(3)} (Asymmetric)`);
                } else {
                    sequenceData[sampleIndex] = clampedAmplitude;
                    updateStatus(`Sample ${sampleIndex}: ${clampedAmplitude.toFixed(3)}`);
                }
                
                analyzeSequence();
                drawPlot();
                updateSampleDisplay();
            }
        }
        
        // Perform harmonic analysis using DFT
        function analyzeSequence() {
            const N = sequenceData.length;
            const numHarmonics = Math.min(10, Math.floor(N/2));
            
            harmonicAmps = [];
            harmonicPhases = [];
            
            for (let k = 1; k <= numHarmonics; k++) {
                let realPart = 0;
                let imagPart = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    realPart += sequenceData[n] * Math.cos(angle);
                    imagPart += sequenceData[n] * Math.sin(angle);
                }
                
                realPart *= 2/N;
                imagPart *= 2/N;
                
                const amplitude = Math.sqrt(realPart*realPart + imagPart*imagPart);
                const phase = Math.atan2(-imagPart, realPart) * 180/Math.PI;
                
                harmonicAmps.push(amplitude);
                harmonicPhases.push(phase < 0 ? phase + 360 : phase);
            }
            
            updateHarmonicsDisplay();
        }
        
        // Draw the MATLAB-style stem plot
        function drawPlot() {
            const svg = document.getElementById('stemPlot');
            svg.innerHTML = ''; // Clear previous content
            
            // Update dimensions
            const rect = svg.getBoundingClientRect();
            const totalWidth = rect.width;
            const totalHeight = rect.height;
            
            // Create coordinate system
            const xScale = plotWidth / sampleCount;
            const yScale = plotHeight / amplitudeRange;
            
            // Draw grid if enabled
            if (showGrid) {
                drawGrid(svg, totalWidth, totalHeight, xScale, yScale);
            }
            
            // Draw axes
            drawAxes(svg, totalWidth, totalHeight);
            
            // Draw harmonic synthesis curve (red curve)
            drawHarmonicCurve(svg, xScale, yScale);
            
            // Draw stem plot for discrete samples
            drawStemPlot(svg, xScale, yScale);
            
            // Draw legend
            drawLegend(svg, totalWidth);
            
            // Add click handler
            svg.onclick = handlePlotClick;
        }
        
        // Draw grid lines
        function drawGrid(svg, width, height, xScale, yScale) {
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.setAttribute('class', 'grid-lines');
            
            // Vertical grid lines
            for (let i = 0; i <= sampleCount; i++) {
                const x = plotMargin.left + i * xScale;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', plotMargin.top);
                line.setAttribute('x2', x);
                line.setAttribute('y2', plotMargin.top + plotHeight);
                gridGroup.appendChild(line);
            }
            
            // Horizontal grid lines
            const numYLines = 11;
            for (let i = 0; i <= numYLines; i++) {
                const y = plotMargin.top + (i * plotHeight) / numYLines;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', plotMargin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', plotMargin.left + plotWidth);
                line.setAttribute('y2', y);
                gridGroup.appendChild(line);
            }
            
            svg.appendChild(gridGroup);
        }
        
        // Draw coordinate axes
        function drawAxes(svg, width, height) {
            // X-axis
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('class', 'axis-line');
            xAxis.setAttribute('x1', plotMargin.left);
            xAxis.setAttribute('y1', plotMargin.top + plotHeight/2);
            xAxis.setAttribute('x2', plotMargin.left + plotWidth);
            xAxis.setAttribute('y2', plotMargin.top + plotHeight/2);
            svg.appendChild(xAxis);
            
            // Y-axis
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('class', 'axis-line');
            yAxis.setAttribute('x1', plotMargin.left);
            yAxis.setAttribute('y1', plotMargin.top);
            yAxis.setAttribute('x2', plotMargin.left);
            yAxis.setAttribute('y2', plotMargin.top + plotHeight);
            svg.appendChild(yAxis);
            
            // X-axis labels
            for (let i = 0; i < sampleCount; i += Math.max(1, Math.floor(sampleCount/10))) {
                const x = plotMargin.left + (i * plotWidth) / sampleCount;
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', plotMargin.top + plotHeight + 20);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('class', 'axis-text');
                text.textContent = i.toString();
                svg.appendChild(text);
            }
            
            // Y-axis labels
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = plotMargin.top + (i * plotHeight) / ySteps;
                const value = amplitudeRange/2 - (i * amplitudeRange) / ySteps;
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', plotMargin.left - 10);
                text.setAttribute('y', y + 4);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('class', 'axis-text');
                text.textContent = value.toFixed(1);
                svg.appendChild(text);
            }
            
            // Axis labels
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', plotMargin.left + plotWidth/2);
            xLabel.setAttribute('y', plotMargin.top + plotHeight + 45);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('class', 'axis-label');
            xLabel.textContent = 'Sample Index (n)';
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 20);
            yLabel.setAttribute('y', plotMargin.top + plotHeight/2);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('class', 'axis-label');
            yLabel.setAttribute('transform', `rotate(-90, 20, ${plotMargin.top + plotHeight/2})`);
            yLabel.textContent = 'Amplitude';
            svg.appendChild(yLabel);
        }
        
        // Draw harmonic synthesis curve
        function drawHarmonicCurve(svg, xScale, yScale) {
            if (harmonicAmps.length === 0) return;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('class', 'interpolated-curve');
            
            let pathData = '';
            const resolution = sampleCount * 10; // Higher resolution for smooth curve
            
            // Generate the curve and store values
            const curveValues = [];
            for (let i = 0; i <= resolution; i++) {
                const t = i / resolution; // 0 to 1 over one period
                let amplitude = 0;
                
                // Sum harmonics with original phase application
                for (let h = 0; h < harmonicAmps.length; h++) {
                    const harmonic = h + 1;
                    const phaseRad = harmonicPhases[h] * Math.PI / 180;
                    amplitude += harmonicAmps[h] * Math.cos(2 * Math.PI * harmonic * t + phaseRad);
                }
                
                curveValues.push(amplitude);
            }
            
            // Manually reverse the time sequence [n:-1:1]
            curveValues.reverse();
            
            // Draw the reversed curve
            for (let i = 0; i <= resolution; i++) {
                const t = i / resolution;
                const amplitude = curveValues[i];
                
                const x = plotMargin.left + t * plotWidth;
                const y = plotMargin.top + plotHeight/2 - amplitude * yScale / 2;
                
                if (i === 0) {
                    pathData += `M ${x} ${y}`;
                } else {
                    pathData += ` L ${x} ${y}`;
                }
            }
            
            path.setAttribute('d', pathData);
            svg.appendChild(path);
        }
        
        // Draw stem plot for discrete samples
        function drawStemPlot(svg, xScale, yScale) {
            for (let i = 0; i < sequenceData.length; i++) {
                const x = plotMargin.left + (i * plotWidth) / sampleCount;
                const y0 = plotMargin.top + plotHeight/2; // Zero line
                const y1 = y0 - sequenceData[i] * yScale / 2; // Sample value
                
                // Check if this is an asymmetric highlighted point
                const isAsymmetric = lastAsymmetricIndices.includes(i);
                
                // Draw stem line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('class', isAsymmetric ? 'stem-line asymmetric' : 'stem-line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', y0);
                line.setAttribute('x2', x);
                line.setAttribute('y2', y1);
                svg.appendChild(line);
                
                // Draw marker
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', isAsymmetric ? 'stem-marker asymmetric' : 'stem-marker');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y1);
                circle.setAttribute('r', isAsymmetric ? 5 : 4);
                svg.appendChild(circle);
            }
        }
        
        // Draw legend
        function drawLegend(svg, width) {
            const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const legendHeight = asymmetricMode && lastAsymmetricIndices.length > 0 ? 70 : 50;
            
            const legendBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            legendBg.setAttribute('x', width - 200);
            legendBg.setAttribute('y', 15);
            legendBg.setAttribute('width', 180);
            legendBg.setAttribute('height', legendHeight);
            legendBg.setAttribute('class', 'legend');
            legendGroup.appendChild(legendBg);
            
            // Discrete samples legend
            const stemLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            stemLine.setAttribute('x1', width - 190);
            stemLine.setAttribute('y1', 30);
            stemLine.setAttribute('x2', width - 170);
            stemLine.setAttribute('y2', 30);
            stemLine.setAttribute('class', 'stem-line');
            legendGroup.appendChild(stemLine);
            
            const stemMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            stemMarker.setAttribute('cx', width - 170);
            stemMarker.setAttribute('cy', 30);
            stemMarker.setAttribute('r', 3);
            stemMarker.setAttribute('class', 'stem-marker');
            legendGroup.appendChild(stemMarker);
            
            const stemText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            stemText.setAttribute('x', width - 160);
            stemText.setAttribute('y', 34);
            stemText.setAttribute('class', 'axis-text');
            stemText.textContent = 'Discrete Samples';
            legendGroup.appendChild(stemText);
            
            // Harmonic synthesis legend
            const curveLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            curveLine.setAttribute('x1', width - 190);
            curveLine.setAttribute('y1', 50);
            curveLine.setAttribute('x2', width - 170);
            curveLine.setAttribute('y2', 50);
            curveLine.setAttribute('class', 'interpolated-curve');
            legendGroup.appendChild(curveLine);
            
            const curveText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            curveText.setAttribute('x', width - 160);
            curveText.setAttribute('y', 54);
            curveText.setAttribute('class', 'axis-text');
            curveText.textContent = 'Harmonic Synthesis';
            legendGroup.appendChild(curveText);
            
            // Asymmetric samples legend (if active)
            if (asymmetricMode && lastAsymmetricIndices.length > 0) {
                const asymLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                asymLine.setAttribute('x1', width - 190);
                asymLine.setAttribute('y1', 70);
                asymLine.setAttribute('x2', width - 170);
                asymLine.setAttribute('y2', 70);
                asymLine.setAttribute('class', 'stem-line asymmetric');
                legendGroup.appendChild(asymLine);
                
                const asymMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                asymMarker.setAttribute('cx', width - 170);
                asymMarker.setAttribute('cy', 70);
                asymMarker.setAttribute('r', 4);
                asymMarker.setAttribute('class', 'stem-marker asymmetric');
                legendGroup.appendChild(asymMarker);
                
                const asymText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                asymText.setAttribute('x', width - 160);
                asymText.setAttribute('y', 74);
                asymText.setAttribute('class', 'axis-text');
                asymText.textContent = 'Asymmetric Points';
                legendGroup.appendChild(asymText);
            }
            
            svg.appendChild(legendGroup);
        }
        
        // Update harmonics display
        function updateHarmonicsDisplay() {
            const container = document.getElementById('harmonicsDisplay');
            container.innerHTML = '';
            
            for (let i = 0; i < harmonicAmps.length; i++) {
                const div = document.createElement('div');
                div.className = 'harmonic-item';
                
                const amplitude = harmonicAmps[i];
                const phase = harmonicPhases[i];
                const frequency = fundamentalFreq * (i + 1);
                const db = amplitude > 0 ? (20 * Math.log10(amplitude)).toFixed(1) : '-‚àû';
                
                div.innerHTML = `
                    <div class="harmonic-label">H${i + 1}</div>
                    <div class="harmonic-freq">${frequency.toFixed(0)} Hz</div>
                    <div class="harmonic-value">${db} dB</div>
                    <div class="harmonic-phase">‚à†${phase.toFixed(0)}¬∞</div>
                `;
                
                container.appendChild(div);
            }
        }
        
        // Update sample display
        function updateSampleDisplay() {
            const container = document.getElementById('sampleValues');
            let content = '';
            
            for (let i = 0; i < sequenceData.length; i++) {
                const isAsymmetric = lastAsymmetricIndices.includes(i);
                const marker = isAsymmetric ? '‚òÖ ' : '  ';
                content += `${marker}x[${i.toString().padStart(2)}] = ${sequenceData[i].toFixed(4)}\n`;
            }
            
            container.textContent = content;
        }
        
        // Update status bar
        function updateStatus(message) {
            const status = document.getElementById('statusBar');
            const period = (1000 / fundamentalFreq).toFixed(2);
            status.textContent = `${message} ‚Ä¢ Fundamental: ${fundamentalFreq} Hz ‚Ä¢ Period: ${period} ms ‚Ä¢ Samples: ${sampleCount}`;
            
            setTimeout(() => {
                status.textContent = `Ready ‚Ä¢ Fundamental: ${fundamentalFreq} Hz ‚Ä¢ Period: ${period} ms ‚Ä¢ Samples: ${sampleCount}`;
            }, 3000);
        }
        
        // Control functions
        function updateSampleCount() {
            const input = document.getElementById('sampleCount');
            sampleCount = parseInt(input.value);
            generateDefaultSequence();
            updateSliderRanges();
            updateIndexDisplay();
            drawPlot();
            updateSampleDisplay();
            lastAsymmetricIndices = []; // Clear asymmetric highlighting
            updateStatus(`Sample count updated to ${sampleCount}`);
        }
        
        function updateFundamental() {
            const input = document.getElementById('fundamentalFreq');
            fundamentalFreq = parseFloat(input.value);
            updateHarmonicsDisplay();
            updateStatus(`Fundamental frequency updated to ${fundamentalFreq} Hz`);
        }
        
        function updateAmplitudeRange() {
            const select = document.getElementById('amplitudeRange');
            amplitudeRange = parseFloat(select.value);
            updateSliderRanges();
            updateAmplitudeDisplay();
            drawPlot();
            updateStatus(`Amplitude range updated to ¬±${amplitudeRange/2}`);
        }
        
        // Preset waveform functions
        function loadSineWave() {
            for (let n = 0; n < sampleCount; n++) {
                const phase = (2 * Math.PI * n) / sampleCount;
                sequenceData[n] = Math.sin(phase) * 0.8;
            }
            lastAsymmetricIndices = [];
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            updateStatus('Loaded sine wave');
        }
        
        function loadSquareWave() {
            for (let n = 0; n < sampleCount; n++) {
                const phase = (2 * Math.PI * n) / sampleCount;
                sequenceData[n] = Math.sign(Math.sin(phase)) * 0.8;
            }
            lastAsymmetricIndices = [];
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            updateStatus('Loaded square wave');
        }
        
        function loadSawtoothWave() {
            for (let n = 0; n < sampleCount; n++) {
                const t = n / sampleCount;
                sequenceData[n] = (2 * (t - Math.floor(t + 0.5))) * 0.8;
            }
            lastAsymmetricIndices = [];
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            updateStatus('Loaded sawtooth wave');
        }
        
        function loadTriangleWave() {
            for (let n = 0; n < sampleCount; n++) {
                const t = n / sampleCount;
                sequenceData[n] = (2 * Math.abs(2 * (t - Math.floor(t + 0.5))) - 1) * 0.8;
            }
            lastAsymmetricIndices = [];
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            updateStatus('Loaded triangle wave');
        }
        
        function loadImpulse() {
            sequenceData.fill(0);
            sequenceData[0] = 1.0; // Unit impulse at n=0
            lastAsymmetricIndices = [];
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            updateStatus('Loaded unit impulse');
        }
        
        function loadNoise() {
            for (let n = 0; n < sampleCount; n++) {
                sequenceData[n] = (Math.random() - 0.5) * 1.6;
            }
            lastAsymmetricIndices = [];
            analyzeSequence();
            drawPlot();
            updateSampleDisplay();
            updateCurrentValueDisplay();
            updateStatus('Loaded random noise');
        }
        
        // Plot control functions
        function zoomIn() {
            zoomLevel *= 1.2;
            drawPlot();
            updateStatus('Zoomed in');
        }
        
        function zoomOut() {
            zoomLevel /= 1.2;
            drawPlot();
            updateStatus('Zoomed out');
        }
        
        function resetZoom() {
            zoomLevel = 1;
            panOffset = { x: 0, y: 0 };
            drawPlot();
            updateStatus('Zoom reset');
        }
        
        function toggleGrid() {
            showGrid = !showGrid;
            drawPlot();
            updateStatus(showGrid ? 'Grid enabled' : 'Grid disabled');
        }
        
        // Audio functions
        async function playSequence() {
            if (!audioContext) {
                await initAudio();
            }
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            stopPlayback(); // Stop any current playback
            
            try {
                // Generate audio buffer
                const sampleRate = 44100;
                const duration = 1.0;
                const bufferSize = sampleRate * duration;
                const buffer = audioContext.createBuffer(1, bufferSize, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Create audio from harmonic synthesis
                const samplesPerCycle = sampleRate / fundamentalFreq;
                const numCycles = Math.floor(bufferSize / samplesPerCycle);
                
                for (let cycle = 0; cycle < numCycles; cycle++) {
                    const cycleStart = Math.floor(cycle * samplesPerCycle);
                    
                    for (let i = 0; i < samplesPerCycle && (cycleStart + i) < bufferSize; i++) {
                        const t = i / samplesPerCycle; // 0 to 1 over one cycle
                        let amplitude = 0;
                        
                        // Sum harmonics with original phase application
                        for (let h = 0; h < harmonicAmps.length; h++) {
                            const harmonic = h + 1;
                            const phaseRad = harmonicPhases[h] * Math.PI / 180;
                            amplitude += harmonicAmps[h] * Math.cos(2 * Math.PI * harmonic * t + phaseRad);
                        }
                        
                        data[cycleStart + i] = amplitude * 0.3; // Volume control
                    }
                }
                
                // Apply fade in/out
                const fadeSize = Math.floor(0.01 * sampleRate);
                for (let i = 0; i < fadeSize; i++) {
                    const fadeValue = i / fadeSize;
                    data[i] *= fadeValue;
                    data[bufferSize - 1 - i] *= fadeValue;
                }
                
                // Play the buffer
                currentSource = audioContext.createBufferSource();
                currentSource.buffer = buffer;
                currentSource.connect(audioContext.destination);
                currentSource.start();
                
                updateStatus('Playing synthesized audio');
                
                // Update UI
                const playBtn = document.getElementById('playBtn');
                playBtn.innerHTML = '‚è∏Ô∏è Playing';
                playBtn.onclick = stopPlayback;
                
                currentSource.onended = () => {
                    playBtn.innerHTML = '‚ñ∂Ô∏è Play';
                    playBtn.onclick = playSequence;
                    currentSource = null;
                };
                
            } catch (error) {
                console.error('Audio playback error:', error);
                updateStatus('Audio playback failed');
            }
        }
        
        function stopPlayback() {
            if (currentSource) {
                currentSource.stop();
                currentSource = null;
                
                const playBtn = document.getElementById('playBtn');
                playBtn.innerHTML = '‚ñ∂Ô∏è Play';
                playBtn.onclick = playSequence;
                
                updateStatus('Playback stopped');
            }
        }
        
        function scramblePhases() {
            for (let i = 0; i < harmonicPhases.length; i++) {
                if (harmonicAmps[i] > 0.001) { // Only scramble significant harmonics
                    harmonicPhases[i] = Math.random() * 360;
                }
            }
            
            // Regenerate sequence from harmonics with new phases
            regenerateSequenceFromHarmonics();
            lastAsymmetricIndices = [];
            drawPlot();
            updateSampleDisplay();
            updateHarmonicsDisplay();
            updateCurrentValueDisplay();
            updateStatus('Phases scrambled');
        }
        
        function regenerateSequenceFromHarmonics() {
            for (let n = 0; n < sampleCount; n++) {
                const t = n / sampleCount;
                let amplitude = 0;
                
                for (let h = 0; h < harmonicAmps.length; h++) {
                    const harmonic = h + 1;
                    const phaseRad = harmonicPhases[h] * Math.PI / 180;
                    amplitude += harmonicAmps[h] * Math.cos(2 * Math.PI * harmonic * t + phaseRad);
                }
                
                sequenceData[n] = amplitude;
            }
            
            // Normalize to prevent clipping
            const maxAmp = Math.max(...sequenceData.map(Math.abs));
            if (maxAmp > amplitudeRange/2) {
                const scale = (amplitudeRange/2) / maxAmp;
                for (let i = 0; i < sequenceData.length; i++) {
                    sequenceData[i] *= scale;
                }
            }
        }
        
        function clearSequence() {
            sequenceData.fill(0);
            harmonicAmps.fill(0);
            harmonicPhases.fill(0);
            lastAsymmetricIndices = [];
            drawPlot();
            updateSampleDisplay();
            updateHarmonicsDisplay();
            updateCurrentValueDisplay();
            updateStatus('Sequence cleared');
        }
        
        // Export functions
        function exportCSV() {
            let csv = 'Sample_Index,Amplitude,Time_ms,Frequency_Hz,Asymmetric_Pair\n';
            const period = 1000 / fundamentalFreq; // Period in ms
            
            for (let i = 0; i < sequenceData.length; i++) {
                const time = (i / sampleCount) * period;
                const asymmetricPair = sampleCount - 1 - i;
                const isAsymmetric = lastAsymmetricIndices.includes(i) ? 'YES' : 'NO';
                csv += `${i},${sequenceData[i].toFixed(6)},${time.toFixed(6)},${fundamentalFreq},${asymmetricPair}_${isAsymmetric}\n`;
            }
            
            // Add harmonic analysis
            csv += '\n\nHarmonic_Number,Frequency_Hz,Amplitude,Phase_Degrees,Magnitude_dB\n';
            for (let i = 0; i < harmonicAmps.length; i++) {
                const freq = fundamentalFreq * (i + 1);
                const db = harmonicAmps[i] > 0 ? 20 * Math.log10(harmonicAmps[i]) : -Infinity;
                csv += `${i + 1},${freq.toFixed(2)},${harmonicAmps[i].toFixed(6)},${harmonicPhases[i].toFixed(2)},${db.toFixed(2)}\n`;
            }
            
            downloadFile(csv, 'sequence_data.csv', 'text/csv');
            updateStatus('CSV exported');
        }
        
        function exportWAV() {
            if (!audioContext) {
                updateStatus('Audio context not available');
                return;
            }
            
            try {
                // Generate high-quality audio buffer
                const sampleRate = 44100;
                const duration = 2.0; // 2 seconds
                const bufferSize = sampleRate * duration;
                const audioData = new Float32Array(bufferSize);
                
                const samplesPerCycle = sampleRate / fundamentalFreq;
                const numCycles = Math.floor(bufferSize / samplesPerCycle);
                
                for (let cycle = 0; cycle < numCycles; cycle++) {
                    const cycleStart = Math.floor(cycle * samplesPerCycle);
                    
                    for (let i = 0; i < samplesPerCycle && (cycleStart + i) < bufferSize; i++) {
                        const t = i / samplesPerCycle;
                        let amplitude = 0;
                        
                        for (let h = 0; h < harmonicAmps.length; h++) {
                            const harmonic = h + 1;
                            const phaseRad = harmonicPhases[h] * Math.PI / 180;
                            amplitude += harmonicAmps[h] * Math.cos(2 * Math.PI * harmonic * t + phaseRad);
                        }
                        
                        audioData[cycleStart + i] = amplitude * 0.5;
                    }
                }
                
                // Convert to WAV
                const wavBuffer = encodeWAV(audioData, sampleRate);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                downloadFile(blob, 'synthesized_waveform.wav', 'audio/wav');
                updateStatus('WAV exported');
                
            } catch (error) {
                console.error('WAV export error:', error);
                updateStatus('WAV export failed');
            }
        }
        
        function exportJSON() {
            const data = {
                sequenceData: sequenceData,
                harmonicAmps: harmonicAmps,
                harmonicPhases: harmonicPhases,
                sampleCount: sampleCount,
                fundamentalFreq: fundamentalFreq,
                amplitudeRange: amplitudeRange,
                asymmetricMode: asymmetricMode,
                lastAsymmetricIndices: lastAsymmetricIndices,
                timestamp: new Date().toISOString(),
                metadata: {
                    tool: 'MATLAB-Style Stem Plot Analyzer with Asymmetric Setting',
                    version: '1.1',
                    sampleRate: 44100
                }
            };
            
            const jsonString = JSON.stringify(data, null, 2);
            downloadFile(jsonString, 'sequence_analysis.json', 'application/json');
            updateStatus('JSON exported');
        }
        
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    if (file.name.endsWith('.json')) {
                        const data = JSON.parse(e.target.result);
                        
                        if (data.sequenceData) {
                            sequenceData = [...data.sequenceData];
                            sampleCount = data.sampleCount || sequenceData.length;
                            fundamentalFreq = data.fundamentalFreq || 440;
                            amplitudeRange = data.amplitudeRange || 2;
                            asymmetricMode = data.asymmetricMode || false;
                            lastAsymmetricIndices = data.lastAsymmetricIndices || [];
                            
                            // Update UI controls
                            document.getElementById('sampleCount').value = sampleCount;
                            document.getElementById('fundamentalFreq').value = fundamentalFreq;
                            document.getElementById('amplitudeRange').value = amplitudeRange;
                            document.getElementById('asymmetricMode').checked = asymmetricMode;
                            
                            if (data.harmonicAmps && data.harmonicPhases) {
                                harmonicAmps = [...data.harmonicAmps];
                                harmonicPhases = [...data.harmonicPhases];
                            } else {
                                analyzeSequence();
                            }
                            
                            toggleAsymmetricMode(); // Update UI based on asymmetric mode
                            drawPlot();
                            updateSampleDisplay();
                            updateHarmonicsDisplay();
                            updateCurrentValueDisplay();
                            updateStatus('JSON data imported');
                        }
                        
                    } else if (file.name.endsWith('.csv')) {
                        // Parse CSV data
                        const lines = e.target.result.split('\n');
                        const newSequenceData = [];
                        
                        for (let i = 1; i < lines.length; i++) { // Skip header
                            const parts = lines[i].split(',');
                            if (parts.length >= 2 && parts[1].trim() !== '') {
                                newSequenceData.push(parseFloat(parts[1]));
                            }
                        }
                        
                        if (newSequenceData.length > 0) {
                            sequenceData = newSequenceData;
                            sampleCount = sequenceData.length;
                            document.getElementById('sampleCount').value = sampleCount;
                            lastAsymmetricIndices = [];
                            
                            analyzeSequence();
                            drawPlot();
                            updateSampleDisplay();
                            updateCurrentValueDisplay();
                            updateStatus('CSV data imported');
                        }
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    updateStatus('Import failed - invalid file format');
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Clear file input
        }
        
        // Utility functions
        function downloadFile(content, filename, mimeType) {
            const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }
        
        function encodeWAV(audioData, sampleRate) {
            const length = audioData.length;
            const buffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(buffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            // Convert float samples to 16-bit PCM
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, audioData[i]));
                view.setInt16(44 + i * 2, sample * 0x7FFF, true);
            }
            
            return buffer;
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(drawPlot, 100);
        });
    </script>
</body>
</html>